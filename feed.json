{
    "version": "https://jsonfeed.org/version/1",
    "title": "CenYi",
    "description": "",
    "home_page_url": "https://imcenyi.github.io",
    "items": [
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%86%E5%B0%8F%E6%93%8D%E4%BD%9C/win11%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BB%86%E5%B0%8F%E6%93%8D%E4%BD%9C/win11%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.294Z",
            "content_html": "<h1 id=\"方法1\"><a class=\"markdownIt-Anchor\" href=\"#方法1\">#</a> 方法 1</h1>\n<h2 id=\"winr-打开命令行工具输入control-system-打开高级系统设置点击环境变量将工具的bin文件的路径加入到环境变量path中\"><a class=\"markdownIt-Anchor\" href=\"#winr-打开命令行工具输入control-system-打开高级系统设置点击环境变量将工具的bin文件的路径加入到环境变量path中\">#</a> win+R  打开命令行工具，输入 control system 打开高级系统设置，点击环境变量，将工具的（bin 文件）的路径加入到环境变量 path 中。</h2>\n<h1 id=\"方法2\"><a class=\"markdownIt-Anchor\" href=\"#方法2\">#</a> 方法 2</h1>\n<h2 id=\"直接通过-设置-系统-高级系统设置-进入到control-system\"><a class=\"markdownIt-Anchor\" href=\"#直接通过-设置-系统-高级系统设置-进入到control-system\">#</a> 直接通过 设置 -&gt; 系统 -&gt; 高级系统设置 -&gt; 进入到 control system</h2>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Unity%E5%BC%95%E6%93%8E/public%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Unity%E5%BC%95%E6%93%8E/public%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.289Z",
            "content_html": "<p>如果在 Unity 引擎中的对象中挂在的脚本里。<br>\n有 public 访问修饰符。会在脚本模块下看到这个变量，并进行赋值。<br>\n这个赋值的优先级很高，会覆盖掉脚本代码之中初始化定义的赋值。</p>\n<pre><code class=\"language-C#\">    public enum emAction\n\n    &#123;\n\n        None=0,\n\n        GetUp,//1\n\n        Wash,//2\n\n        Eat,//3\n\n        Work,//4\n\n    &#125;\n\n    public emAction mAction = emAction.Work;\n    Debug.Log((int)mAction);\n</code></pre>\n<p>我们对 <code>mAction</code>  的初始划定义是 Work，照理来说的应该在终端打印出 4，但实际上。<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230139957.png\" alt=\"Pasted image 20230616154518.png\"></p>\n<p>如果我们在脚本的选项中，选择了 mAction 的<mark>初值</mark>，那么这个值将覆盖脚本代码中的<mark>初始值</mark>（注意，只是初始值）。</p>\n<p>上面那个举得实例中，我们在 Unity 选择了 None 覆盖了我们初始化定义 <code>mAction</code>  所附的 Work。所以打印出来的还是 None 的 0。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.286Z",
            "content_html": "<p>访问等级（Access Level）是指在 C# 中用于控制类、结构体、接口、字段、属性、方法和构造函数等成员的可访问性的修饰符。C# 中有五个访问等级，从高到低分别是：</p>\n<ol>\n<li><code>public</code> ：公共的，可以被任何代码访问。</li>\n<li><code>protected internal</code> ：受保护的内部的，可以被同一程序集中的代码和派生类中的代码访问。</li>\n<li><code>internal</code> ：内部的，可以被同一程序集中的代码访问。</li>\n<li><code>protected</code> ：受保护的，可以被派生类中的代码和同一程序集中的代码访问。</li>\n<li><code>private</code> ：私有的，只能被同一类中的代码访问。</li>\n</ol>\n<p>访问等级可以帮助您控制代码的可访问性，从而提高代码的安全性和可维护性。例如，将某些成员设置为 <code>private</code>  可以防止其他代码意外地修改它们，从而提高代码的安全性。将某些成员设置为 <code>public</code>  可以使其他代码更容易地使用它们，从而提高代码的可维护性。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E5%AF%86%E5%B0%81%E7%B1%BB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E5%AF%86%E5%B0%81%E7%B1%BB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.279Z",
            "content_html": "<p>/*  抽象类</p>\n<p>1. 抽象类不可以被实例化</p>\n<p>2. 抽象函数只能写在抽象类之中，并且抽象函数不能有方法体</p>\n<p>3. 抽象类的子类必须实现抽象类中的所有抽象函数</p>\n<p>4. 抽象类中可以有非抽象函数</p>\n<p>5. 抽象类可以继承抽象类，但是子类必须实现所有抽象函数</p>\n<p>6. 非抽象类可以继承抽象类，但是子类必须实现所有抽象函数</p>\n<p>*/</p>\n<h2 id=\"密封类\"><a class=\"markdownIt-Anchor\" href=\"#密封类\">#</a> 密封类</h2>\n<p>1. 密封类不可以被继承（他只能是子类）</p>\n<p>2. 密封类不能是抽象的。sealed 和 abstract 是互斥的</p>\n<p>（其实很好理解，密封类不能作为基类，只能是子类</p>\n<p>而抽象类虽然可以既是基类又是子类，但是其中的抽</p>\n<p>象函数是不能在抽象类中写方法体的，必须要在子类</p>\n<p>中实现，这就和密封类的定义【不可被继承，不能有子类】相违背了）</p>\n<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230142194.png\" alt=\"Pasted image 20230621161128.png\"></p>\n<h3 id=\"上述报错表明了抽象类和封闭类是互斥的\"><a class=\"markdownIt-Anchor\" href=\"#上述报错表明了抽象类和封闭类是互斥的\">#</a> 上述报错，表明了抽象类和封闭类是互斥的</h3>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%B1%BB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E7%B1%BB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.279Z",
            "content_html": "<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230141676.png\" alt=\"Pasted image 20230621154506.png\"></p>\n<h1 id=\"抽象类不可被实例化\"><a class=\"markdownIt-Anchor\" href=\"#抽象类不可被实例化\">#</a> 抽象类不可被实例化</h1>\n<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230141139.png\" alt=\"Pasted image 20230621154709.png\"></p>\n<h1 id=\"抽象类之中的抽象函数必须在子类写好实现的方法体\"><a class=\"markdownIt-Anchor\" href=\"#抽象类之中的抽象函数必须在子类写好实现的方法体\">#</a> 抽象类之中的抽象函数必须在<mark>子类写好实现的方法体</mark></h1>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E9%9D%99%E6%80%81%E7%B1%BB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E9%9D%99%E6%80%81%E7%B1%BB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.279Z",
            "content_html": "<p>静态变量不可以通过实例来访问，只能通过类名，因为他是共有的。<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230139796.png\" alt=\"Pasted image 20230620180951.png\"><br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230140156.png\" alt=\"Pasted image 20230620181011.png\"><br>\n 上面是错误示范<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230141887.png\" alt=\"Pasted image 20230620181325.png\"></p>\n<pre><code>应该使用MyClass3这个类名而不是myClass3这个实例\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%B3%9B%E5%9E%8B%E7%B1%BB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%B3%9B%E5%9E%8B%E7%B1%BB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.279Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%8E%A5%E5%8F%A3/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E7%B1%BB%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F/%E6%8E%A5%E5%8F%A3/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.279Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7%E8%A7%84%E5%88%99%20enum/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E7%AD%89%E7%BA%A7%E8%A7%84%E5%88%99%20enum/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.271Z",
            "content_html": "<pre><code class=\"language-C#\"> enum emAction\n&#123;\n    GetUp,\n    Wash,\n    Eat,\n    Work,\n&#125;\n\npublic emAction Action;\n</code></pre>\n<p>上面这串代码出现了一个错误，即 <code>emAction</code>  枚举类型的访问修饰符与 <code>mAction</code>  字段的访问修饰符不匹配。具体来说， <code>emAction</code>  枚举类型是默认的（即没有访问修饰符），而 <code>Action</code>  字段是公共的（ <code>public</code> ）。</p>\n<h3 id=\"这违反了c的访问性限制\"><a class=\"markdownIt-Anchor\" href=\"#这违反了c的访问性限制\">#</a> 这违反了 C# 的访问性限制</h3>\n<p>因为一个字段的可访问性不能高于其类型的可访问性。因此，您需要将 <code>emAction</code>  枚举类型的访问修饰符更改为公共的（ <code>public</code> ）或将 <code>mAction</code>  字段的访问修饰符更改为默认 (private 级别) 的（即删除 <code>public</code>  关键字）。</p>\n<pre><code class=\"language-C#\">enum emAction\n</code></pre>\n<p>我们可以看到上面那串代码之中，所定义的 emAction 枚举类。前面没有刻意加上访问修饰符，则默认是 <code>private</code>  访问等级，是最低一级。<br>\n<mark>关于访问等级先后详细看 [[访问等级]]</mark><br>\n 如果 <code>Action</code>  字段是 <code>public</code> ，则将 <code>emAction</code>  枚举类型的可访问性设置为 <code>private</code>  是不合适的，因为这会违反 C# 的访问性规则。一个字段的可访问性不能高于其类型的可访问性。</p>\n<h3 id=\"那为什么c要有这个访问性限制呢-其实也不难理解\"><a class=\"markdownIt-Anchor\" href=\"#那为什么c要有这个访问性限制呢-其实也不难理解\">#</a> 那为什么 C# 要有这个访问性限制呢。其实也不难理解</h3>\n<p>C# 中语段的访问等级不能高于枚举类型的访问等级，是因为一个语段（如字段、属性、方法等）的可访问性依赖于其类型的可访问性。如果一个语段的类型的可访问性比它本身的可访问性更低，那么这个语段就不能被访问，因为它的类型不可访问。</p>\n<p>例如，在这个示例中， <code>mAction</code>  字段的访问修饰符是 <code>public</code> ，而 <code>emAction</code>  枚举类型的访问修饰符是默认的（即 <code>private</code> ）。这违反了 C# 的访问性规则，因为一个字段的可访问性不能高于其类型的可访问性。因此，编译器会报错，提示 <code>emAction</code>  枚举类型的可访问性低于 <code>mAction</code>  字段的可访问性。</p>\n<p>说白了，这个语段的访问，必须要访问到这个枚举类型本身，如果这个语段的访问性比枚举类型高，那么对于这个语段的访问就不成立。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E7%BA%BF%E6%80%A7%EF%BC%89/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%88%E7%BA%BF%E6%80%A7%EF%BC%89/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.271Z",
            "content_html": "<pre><code class=\"language-C#\">    void Func1()\n\n    &#123;\n\n        int value1=15;\n\n        if(value1&gt;5)\n\n        &#123;\n\n            Debug.Log(&quot;value1 is greater than 5&quot;);//value1满足了第一个条件就执行了，输出语句\n\n        &#125;\n\n        else if(value1&gt;10)\n\n        &#123;\n\n            Debug.Log(&quot;value1 is greater than 10&quot;);//由于第一个已经执行了，就终端这一串条件语句，所以虽然满足条件但没有执行\n\n        &#125;\n\n        else\n\n        &#123;\n\n            Debug.Log(&quot;value1 is less than 5&quot;);\n\n        &#125;\n\n    &#125;\n\n&#125;\n</code></pre>\n<h1 id=\"条件检测是线性的只要满足前面的就不会执行后面的\"><a class=\"markdownIt-Anchor\" href=\"#条件检测是线性的只要满足前面的就不会执行后面的\">#</a> 条件检测是线性的，只要满足前面的就不会执行后面的</h1>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E7%BB%A7%E6%89%BF/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E7%BB%A7%E6%89%BF/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.271Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E8%99%9A%E6%96%B9%E6%B3%95/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E8%99%9A%E6%96%B9%E6%B3%95/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.271Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88abstruct%EF%BC%89%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95(virtual)%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88abstruct%EF%BC%89%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95(virtual)%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.269Z",
            "content_html": "<p><mark>实际上虚函数就类似于初省值</mark></p>\n<h3 id=\"抽象函数只能定义在抽象类中并且不能在基类中写入方法体只能写在子类实现\"><a class=\"markdownIt-Anchor\" href=\"#抽象函数只能定义在抽象类中并且不能在基类中写入方法体只能写在子类实现\">#</a> <mark>抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现</mark></h3>\n<p>抽象方法和虚函数都是面向对象编程中的重要概念，它们都可以在基类中声明，然后在派生类中进行实现。它们的主要区别在于：</p>\n<ol>\n<li>抽象方法必须在派生类中进行实现，而虚函数可以选择在派生类中进行重写。</li>\n<li>抽象方法没有实现，只有方法签名，而虚函数有默认的实现 ==（必须）==，可以在基类中提供。</li>\n<li>抽象方法只能在抽象类中声明，而虚函数可以在普通的类中声明。</li>\n</ol>\n<p>下面是一个示例，演示了如何在抽象类中声明抽象方法和在普通类中声明虚函数：</p>\n<pre><code class=\"language-C#\">abstract class Shape\n\n&#123;\n\n    public abstract double GetArea();//这里的方法体必须是空\n\n&#125;\n\nclass Rectangle : Shape\n\n&#123;\n\n    public double Width &#123; get; set; &#125;\n\n    public double Height &#123; get; set; &#125;\n\n    public override double GetArea()//子类写入方法体实现\n\n    &#123;\n\n        return Width * Height;\n\n    &#125;\n\n&#125;\nclass Circle : Shape\n\n&#123;\n\n    public double Radius &#123; get; set; &#125;\n\n    public override double GetArea(）\n\n    &#123;\n\n        return Math.PI * Radius * Radius;\n\n    &#125;\n\n&#125;\n\nclass Square : Shape\n\n&#123;\n\n    public double Side &#123; get; set; &#125;\n\n    public override double GetArea()\n\n    &#123;\n\n        return Side * Side;\n\n    &#125;\n\n&#125;\n\nclass Triangle : Shape\n\n&#123;\n\n    public double Base &#123; get; set; &#125;\n\n    public double Height &#123; get; set; &#125;\n\n    public override double GetArea()\n\n    &#123;\n\n        return 0.5 * Base * Height;\n\n    &#125;\n\n&#125;\n\n// 使用示例\n\nShape shape1 = new Rectangle &#123; Width = 10, Height = 20 &#125;;\n\nShape shape2 = new Circle &#123; Radius = 5 &#125;;\n\nShape shape3 = new Square &#123; Side = 10 &#125;;\n\nShape shape4 = new Triangle &#123; Base = 10, Height = 5 &#125;;\n\nConsole.WriteLine(shape1.GetArea()); // 输出：200\n\nConsole.WriteLine(shape2.GetArea()); // 输出：78.53981633974483\n\nConsole.WriteLine(shape3.GetArea()); // 输出：100\n\nConsole.WriteLine(shape4.GetArea()); // 输出：25\n</code></pre>\n<p>在这个示例中，我们定义了一个抽象类 <code>Shape</code>  和四个子类 <code>Rectangle</code> 、 <code>Circle</code> 、 <code>Square</code>  和 <code>Triangle</code> ，它们都重写了 <code>GetArea</code>  方法。 <code>GetArea</code>  方法是一个抽象方法，必须在子类中实现。在使用示例中，我们创建了四个不同的形状对象，并分别调用它们的 <code>GetArea</code>  方法，输出了它们的面积。</p>\n<p><code>abstract</code>  和 <code>virtual</code>  都是 C# 中用于实现多态的关键字，它们的主要区别在于：</p>\n<ol>\n<li><code>abstract</code>  用于声明抽象方法，它必须在派生类中进行实现，而 <code>virtual</code>  用于声明虚方法，它可以在派生类中进行重写，但不是必须的。</li>\n<li><code>abstract</code>  方法没有实现，只有方法签名，而 <code>virtual</code>  方法有默认的实现，可以在基类中提供。</li>\n<li><code>abstract</code>  方法只能在抽象类中声明，而 <code>virtual</code>  方法可以在普通的类中声明。</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.269Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%B0%81%E8%A3%85/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%B0%81%E8%A3%85/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.261Z",
            "content_html": "<h2 id=\"封装的主要目的\"><a class=\"markdownIt-Anchor\" href=\"#封装的主要目的\">#</a> 封装的主要目的</h2>\n<p>封装的主要目的是将数据和行为组合在一个单元中，并对外部隐藏数据的实现细节，只暴露必要的接口供外部访问。这样可以提高代码的可维护性、可重用性和安全性。</p>\n<p>封装可以防止外部代码直接访问和修改对象的内部状态，从而避免了意外的数据修改和错误的数据访问。同时，封装还可以隐藏对象的实现细节，使得对象的实现可以自由地修改，而不会影响到外部代码的使用。</p>\n<p>在面向对象编程中，封装是三大特性之一，另外两个是继承和多态。封装是面向对象编程的基础，它可以使得代码更加模块化、可维护性更高、可重用性更好，从而提高代码的质量和效率。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.261Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%A4%9A%E6%80%81/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%A4%9A%E6%80%81/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.261Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%88%9B%E5%BB%BA%E7%B1%BB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/%E5%88%9B%E5%BB%BA%E7%B1%BB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.261Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/this%20%E5%92%8C%20base%20%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Csharp/Class%E7%B1%BB/this%20%E5%92%8C%20base%20%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.256Z",
            "content_html": "<p><code>this</code>  和 <code>base</code>  都是 C# 中的关键字，它们的主要区别在于：</p>\n<ol>\n<li><code>this</code>  关键字用于引用当前对象，可以用来访问当前对象的成员变量、成员方法和构造函数等。 <code>this</code>  关键字可以用于区分局部变量和成员变量、调用其他构造函数、实现链式调用等场景。</li>\n<li><code>base</code>  关键字用于引用基类对象，可以用来访问基类的成员变量、成员方法和构造函数等。 <code>base</code>  关键字可以用于在派生类中调用基类的构造函数、访问基类中被隐藏的成员等场景。</li>\n</ol>\n<p>以下是一个示例，演示了如何使用 <code>this</code>  和 <code>base</code>  关键字：</p>\n<pre><code class=\"language-C#\">class Person\n\n&#123;\n\n    public string Name &#123; get; set; &#125;\n\n    public int Age &#123; get; set; &#125;\n\n    public Person(string name, int age)\n\n    &#123;\n\n        this.Name = name;\n\n        this.Age = age;\n\n    &#125;\n\n&#125;\n\nclass Student : Person\n\n&#123;\n\n    public string School &#123; get; set; &#125;\n\n    public Student(string name, int age, string school) : base(name, age)\n\n    &#123;\n\n        this.School = school;\n\n    &#125;\n\n    public void Study()\n\n    &#123;\n\n        Console.WriteLine(&quot;&#123;0&#125; is studying at &#123;1&#125;.&quot;, this.Name, this.School);\n\n    &#125;\n\n    public void ShowInfo()\n\n    &#123;\n\n        Console.WriteLine(&quot;Name: &#123;0&#125;, Age: &#123;1&#125;, School: &#123;2&#125;&quot;, this.Name, this.Age, this.School);\n\n    &#125;\n\n&#125;\n\n// 使用示例\n\nStudent student = new Student(&quot;Tom&quot;, 18, &quot;ABC School&quot;);\n\nstudent.Study(); // 输出：Tom is studying at ABC School.\n\nstudent.ShowInfo(); // 输出：Name: Tom, Age: 18, School: ABC School\n</code></pre>\n<p>在这个示例中，我们定义了一个 <code>Person</code>  类和一个 <code>Student</code>  类， <code>Student</code>  类继承自 <code>Person</code>  类。在 <code>Person</code>  类中，我们定义了一个构造函数，使用 <code>this</code>  关键字来引用当前对象的成员变量。在 <code>Student</code>  类中，我们定义了一个构造函数，使用 <code>base</code>  关键字来调用基类的构造函数。在 <code>Student</code>  类中，我们还定义了两个方法 <code>Study</code>  和 <code>ShowInfo</code> ，分别使用 <code>this</code>  关键字和 <code>base</code>  关键字来访问当前对象和基类对象的成员变量。在使用示例中，我们创建了一个 <code>Student</code>  对象，并调用了它的 <code>Study</code>  和 <code>ShowInfo</code>  方法，输出了相应的信息。</p>\n<p>总的来说， <code>this</code>  关键字用于引用当前对象， <code>base</code>  关键字用于引用基类对象。它们的应用场景不同， <code>this</code>  关键字通常用于访问当前对象的成员， <code>base</code>  关键字通常用于在派生类中调用基类的构造函数或访问基类中被隐藏的成员。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.256Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%201/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%201/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.253Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%203/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%203/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.253Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%202/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/C++/%E6%9C%AA%E5%91%BD%E5%90%8D%202/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.253Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/Debug.Log/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/Debug.Log/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.245Z",
            "content_html": "<h1 id=\"一定要记得log的l大写\"><a class=\"markdownIt-Anchor\" href=\"#一定要记得log的l大写\">#</a> 一定要记得 Log 的 L 大写！！！！</h1>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87vscode%E8%BF%90%E8%A1%8CCS%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/%E7%9B%B4%E6%8E%A5%E9%80%9A%E8%BF%87vscode%E8%BF%90%E8%A1%8CCS%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.245Z",
            "content_html": "<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230142390.png\" alt=\"Pasted image 20230614104941.png\"></p>\n<h2 id=\"这个c脚本文件在unity所开的项目中可以正常运行但为什么直接在vscode运行不行呢\"><a class=\"markdownIt-Anchor\" href=\"#这个c脚本文件在unity所开的项目中可以正常运行但为什么直接在vscode运行不行呢\">#</a> 这个 C# 脚本文件在 Unity 所开的项目中可以正常运行，但为什么直接在 vscode 运行不行呢。</h2>\n<h3 id=\"1首先是报错的原因\"><a class=\"markdownIt-Anchor\" href=\"#1首先是报错的原因\">#</a> 1. 首先是报错的原因</h3>\n<p>这个错误提示意味着 PowerShell 无法找到名为 scriptcs 的命令。这通常是因为 scriptcs 没有被正确安装或者没有被添加到系统的 PATH 环境变量中。请确保您已经正确安装了 scriptcs，并将其添加到 PATH 环境变量中。如果您已经安装了 scriptcs 并且将其添加到了 PATH 环境变量中，那么请检查您的命令是否正确拼写。</p>\n<h2 id=\"2那为什么在unity的项目对象中可以直接运行而不会报错\"><a class=\"markdownIt-Anchor\" href=\"#2那为什么在unity的项目对象中可以直接运行而不会报错\">#</a> 2. 那为什么在 Unity 的项目对象中可以直接运行，而不会报错</h2>\n<p>Unity 引擎已经为您配置好了项目所需的环境，包括编译器、库和其他依赖项。在 Unity 中，您可以直接编写 C# 代码，并且 Unity 引擎会自动编译和运行您的代码。因此，您可以在 Unity 中直接运行这段代码，而不需要手动配置环境。<br>\n在 Unity 中使用了 C# 脚本，那么您不需要使用 scriptcs 来运行它们。Unity 引擎会自动编译和运行您的脚本。因此，如果您在 Unity 中使用 C# 脚本，那么将 scriptcs 添加到 PATH 环境变量中不会对您的 Unity 项目造成任何影响。但是，如果您在 Unity 之外的地方使用 scriptcs 运行 C# 脚本，那么您需要将 scriptcs 添加到 PATH 环境变量中。</p>\n<h2 id=\"解决方法将scriptcs所在的目录加入到环境变量当中\"><a class=\"markdownIt-Anchor\" href=\"#解决方法将scriptcs所在的目录加入到环境变量当中\">#</a> 解决方法，将 scriptcs 所在的目录加入到环境变量当中。</h2>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%93%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E5%86%99%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%B8%AD/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/BUG/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%96%B9%E6%B3%95%E4%BD%93%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%AD%90%E7%B1%BB%E4%B8%AD%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E5%86%99%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%B8%AD/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.245Z",
            "content_html": "<p><mark>抽象方法只能在抽象类中定义</mark><br>\n这个错误提示是因为您在抽象类 <code>Polygon</code>  中声明了一个抽象方法 <code>Purarea</code> ，但是没有为它提供方法体。在 C# 中，抽象方法必须以分号结尾，并且不能有方法体，因为它们没有实现，必须在子类中实现。</p>\n<p>要解决这个问题，您需要为 <code>Purarea</code>  方法提供方法体，或者将 <code>Polygon</code>  类声明为抽象类，以便子类可以实现 <code>Purarea</code>  方法。</p>\n<p>以下是一个示例，演示了如何在 <code>Polygon</code>  类中声明抽象方法：</p>\n<pre><code class=\"language-CS\">\nabstract class Polygon\n\n&#123;\n\n    public abstract void Purarea();\n\n&#125;\n\nclass Rectangle : Polygon\n\n&#123;\n\n    public override void Purarea()\n\n    &#123;\n\n        Console.WriteLine(&quot;Calculate the area of a rectangle.&quot;);\n\n    &#125;\n\n&#125;\n\n// 使用示例\n\nPolygon polygon = new Rectangle();\n\npolygon.Purarea(); // 输出：Calculate the area of a rectangle.\n</code></pre>\n<p>在这个示例中，我们定义了一个抽象类 <code>Polygon</code>  和一个非抽象子类 <code>Rectangle</code> ，它们都实现了 <code>Purarea</code>  方法。在使用示例中，我们创建了一个 <code>Rectangle</code>  对象，并将其赋值给 <code>Polygon</code>  类型的变量 <code>polygon</code> 。然后，我们调用 <code>polygon.Purarea()</code>  方法，它会调用 <code>Rectangle</code>  类中的 <code>Purarea</code>  方法，并输出 <code>Calculate the area of a rectangle.</code> 。</p>\n",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/()/",
            "url": "https://imcenyi.github.io/2023/06/23/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/()/",
            "title": "",
            "date_published": "2023-06-22T17:44:40.204Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/04/17/SHUFLY%E4%BA%A4%E6%B5%81%E4%BC%9A%E6%9C%89%E6%84%9F/",
            "url": "https://imcenyi.github.io/2023/04/17/SHUFLY%E4%BA%A4%E6%B5%81%E4%BC%9A%E6%9C%89%E6%84%9F/",
            "title": "“SHUFLY交流会有感“",
            "date_published": "2023-04-17T15:39:47.000Z",
            "content_html": "<p>首先真的十分感谢在交流会上分享经验的学长学姐们，真的收获很多。特别是对于我这种信息面不是很广的大一新生来说，像是打开了新世界的大门。接下来我将通过三个方面来简述一下我的收获和反省</p>\n<h2 id=\"1个人选择\"><a class=\"markdownIt-Anchor\" href=\"#1个人选择\">#</a> 1. 个人选择</h2>\n<ul>\n<li>\n<p>首先个人选择这一方面，一定是从自身出发，一位数学系的学长说的很好 ==“别人的经验，别人的经历，终究是别人的，而不是自己的，它并没有办法真正左右你的方向，做出选择的永远是自己。”==</p>\n</li>\n<li>\n<p>这对于我来说启发真的很大。近期在周围的压力下和摸索自我的过程中，我仿佛陷入一个泥沼，困与自身的矛盾和焦虑之中，也就是我们常说的<em><strong>精神内耗</strong></em>。对于自我的渴求，和认知的不足，让我的精神深受折磨。于是我便通过网络，或者和一些牛人朋友的交谈，尝试找寻一条适合自己的道路，或者说是想要去模仿，想要去走一条他们走过的路，说白了还是思想上的偷懒。导致了我一直没有走出这个怪圈，而那位学长的话一下子就点醒了我，从一开始我的方向就错了，我只想着最好能找到一条照着走就完事的路。但我忽视了个体之间的差异，别人终究不是我。付出自己的时间成本去不断试错，只有自我承担着这种风险，才能得到真正的成长，走出的才会是真正适合自己的道路。而这也是我作为一个攀爬者成就自我的必由之路。</p>\n</li>\n</ul>\n<h2 id=\"2方向选择深造or就业\"><a class=\"markdownIt-Anchor\" href=\"#2方向选择深造or就业\">#</a> 2. 方向选择（深造 or 就业）</h2>\n<ul>\n<li>我对于这一方面了解的也不是特别多，但能尽可能地早做选择总是没错的。</li>\n</ul>\n<p><mark>针对我个人而言</mark>，我是一个很讨厌按照规矩办事的一个人，准确的说，我很讨厌那种无效和重复的付出。在我行动之前，我一定要先明确，我的目的，以及我如何完成目的，是否有更好的途径来达成我的目的。这就导致了，我不太愿意随大流，走一条相对<em><strong>稳妥</strong></em>的道路。</p>\n<ul>\n<li>\n<h3 id=\"深造or就业\"><a class=\"markdownIt-Anchor\" href=\"#深造or就业\">#</a> <em><strong>深造 or 就业</strong></em></h3>\n</li>\n</ul>\n<p>我目前是偏向于毕业直接投入就业一点（当然随着认知和想法的变化或许会发生改变），或许在大二大三就会开始尝试找实习和项目。至于我为什么不选择去深造读研读博这条路呢，明明大家都在朝这个方向发展，整个大环境给我的感觉就是，不读研就很难有出路。</p>\n<ul>\n<li>\n<h4 id=\"我为自己归纳了以下几个原因\"><a class=\"markdownIt-Anchor\" href=\"#我为自己归纳了以下几个原因\">#</a> 我为自己归纳了以下几个原因</h4>\n</li>\n</ul>\n<ol>\n<li><em><strong>我对于科研事业并不抱有太大的热忱</strong></em>：<br>\n这也是我认为最主要的原因，我认为一个人的主观能动性是非常重要的，一个人要是被强迫去做一个完全不感兴趣的东西，那效率毫无疑问的低的。而且我前面也提到了，我是一个不愿意随大流的人，我不会因为环境的 push，而将过多的心理花在一个不感兴趣的事情上。</li>\n<li><em><strong>不明白科研的方向</strong></em>：<br>\n如果我想去搞研究，我起码要知道自己想研究什么方向吧，总不可能像一只无头苍蝇一样乱飞。当然这也可能是因为我目前还未分流，对于专业认知还不是很清晰导致的。</li>\n<li><em><strong>科研环境</strong></em>：<br>\n目前国内的科研环境一言难尽，而对于出国又碍于自己的外语能力。（在背了在背了）。</li>\n</ol>\n<h2 id=\"3为我坚定了短期方向种数媒雾\"><a class=\"markdownIt-Anchor\" href=\"#3为我坚定了短期方向种数媒雾\">#</a> 3. 为我坚定了短期方向（种‘数媒’（雾））</h2>\n<ul>\n<li>这个最后一点，也是我认为收获最大的一点。在交流会的最后私下提问交流的环境，我有幸认识到了 20 级数媒在读的卢学长，通过和学长的交流，我对于数字媒体技术这个专业有了更加清晰的认知，同样也更加坚定了自己的短期道路 —— 进入数字媒体技术专业。至于为什么会选择这个方向呢。首先我个人是理工科出身，同样对于艺术表达这方面也十分感兴趣（当然可能莫得艺术细胞？）。理工科的出身让我对于计算机方面也十分感兴趣，但是从小开始自己就有这过剩的表达欲，我想把自己所想自己的体会让别人知道，而艺术就是一个很好地载体，在高考备考期间，自己甚至抽出来时间学了学 pr（可能上海确实是毕竟闲），剪映等剪辑软件自己尝试着做做自媒体。虽然说没有多少的流量，并没有让更多人看到，但是在这个过程中，我能真正感受到快乐，那种满足。所以这也是我难以割舍的。那怎么办呢。结论就是 ——==“小孩子才做选择，我全都要”== 这也让我盯上了数字媒体技术，它可以同时满足我对计算机和艺术表达的诉求。当然学校的硬件也很足啊。（三套完备的光学动捕啊。斯哈<sub>斯哈</sub>）</li>\n</ul>\n<h2 id=\"一切都还是刚开始一切都是未知数期待自己接下来的成长\"><a class=\"markdownIt-Anchor\" href=\"#一切都还是刚开始一切都是未知数期待自己接下来的成长\">#</a> 一切都还是刚开始，一切都是未知数，期待自己接下来的成长</h2>\n",
            "tags": [
                "感悟",
                "成长"
            ]
        },
        {
            "id": "https://imcenyi.github.io/2023/04/08/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9C/",
            "url": "https://imcenyi.github.io/2023/04/08/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%9C/",
            "title": "构造函数“",
            "date_published": "2023-04-08T08:19:59.000Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://imcenyi.github.io/2023/04/01/1%20%E5%BC%95%E7%94%A8/",
            "url": "https://imcenyi.github.io/2023/04/01/1%20%E5%BC%95%E7%94%A8/",
            "title": "c++/引用",
            "date_published": "2023-03-31T16:39:59.000Z",
            "content_html": "<p>1. 引用</p>\n<h2 id=\"引用的概念\"><a class=\"markdownIt-Anchor\" href=\"#引用的概念\">#</a> 引用的概念</h2>\n<p>某个变量的引用，<mark>等价于</mark>这个变量，相当于这个变量的<mark>别名</mark></p>\n<p>引用 (&amp;) 语法如下</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> n<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>r<span class=\"token operator\">=</span>n<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>对于 n 的运算，r 同样也会做相同的运算。<br>\n反过来，对于 r 的运算，同样也会作用到 n 上。</p>\n<p>如</p>\n<figure class=\"highlight cpp\"><figcaption data-lang=\"C++\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">int</span> n<span class=\"token operator\">=</span><span class=\"token number\">7</span><span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>r<span class=\"token operator\">=</span>n<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>r<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 这一步运算也作用到了 n 上</span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>cout<span class=\"token operator\">&lt;&lt;</span>r<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>cout<span class=\"token operator\">&lt;&lt;</span>n<span class=\"token punctuation\">;</span></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>n<span class=\"token operator\">=</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// 这一步运算也作用到了 r 上</span></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>cout<span class=\"token operator\">&lt;&lt;</span>r<span class=\"token punctuation\">;</span></pre></td></tr></table></figure><p>最后 r=n=5，可见引用运算同步。</p>\n<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081852656.png\" alt=\"image.png\"></p>\n<p><strong>注意，引用是从一而终的，不可以引用其他变量</strong><br>\n<strong>引用只能引用<mark>变量</mark>，不能引用<s>常量和表达式</s></strong><br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081852848.png\" alt=\"image.png\"><br>\n<strong> 这里 r1=b 这一句，并不是让 r1 引用 b，而是给 r1 赋了 b 的值</strong></p>\n<h2 id=\"引用的作用\"><a class=\"markdownIt-Anchor\" href=\"#引用的作用\">#</a> 引用的作用</h2>\n<p>写一个交换整型变量的值。<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081852854.png\" alt=\"image.png\"></p>\n<p>实际上 n1，n2，并不会改变。</p>\n<p>但是引用可以很好解决这个问题。<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081852954.png\" alt=\"image.png\"></p>\n<p>在这里由与附给形参的类型是引用，所以 a，b 与 n1，n2 等价。<br>\n在子函数里 ab 所做的运算，n1n2 同样也会执行，所以 n1n2 会改变。</p>\n<p>返回值是个引用，则可以对于返回值进行赋值。<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081853831.png\" alt=\"image.png\"></p>\n<h2 id=\"常引用\"><a class=\"markdownIt-Anchor\" href=\"#常引用\">#</a> 常引用</h2>\n<p><img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081853189.png\" alt=\"image.png\"></p>\n<p><strong>注意，不可以通过常引用来改变引用的内容（可以用其他方式）。</strong>!<br>\n<img data-src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202304081854020.png\" alt=\"image.png\"></p>\n",
            "tags": [
                "C++",
                "语言学习",
                "笔记"
            ]
        }
    ]
}