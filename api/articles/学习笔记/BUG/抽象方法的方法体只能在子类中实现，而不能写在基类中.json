{"title":"c#bug-抽象方法只能在抽象类中定义","uid":"52ac0bc4af2a723f9f23e72acd05d595","slug":"学习笔记/BUG/抽象方法的方法体只能在子类中实现，而不能写在基类中","date":"2023-06-22T16:39:59.000Z","updated":"2023-07-05T10:55:25.480Z","comments":true,"path":"api/articles/学习笔记/BUG/抽象方法的方法体只能在子类中实现，而不能写在基类中.json","keywords":null,"cover":null,"content":"<h2 id=\"抽象方法只能在抽象类中定义\"><a class=\"markdownIt-Anchor\" href=\"#抽象方法只能在抽象类中定义\">#</a> 抽象方法只能在抽象类中定义</h2>\n<p>这个错误提示是因为您在抽象类 <code>Polygon</code>  中声明了一个抽象方法 <code>Purarea</code> ，但是没有为它提供方法体。在 C# 中，抽象方法必须以分号结尾，并且不能有方法体，因为它们没有实现，必须在子类中实现。</p>\n<p>要解决这个问题，您需要为 <code>Purarea</code>  方法提供方法体，或者将 <code>Polygon</code>  类声明为抽象类，以便子类可以实现 <code>Purarea</code>  方法。</p>\n<p>以下是一个示例，演示了如何在 <code>Polygon</code>  类中声明抽象方法：</p>\n<pre class=\"line-numbers language-CS\" data-language=\"CS\"><code class=\"language-CS\">\nabstract class Polygon\n\n&#123;\n\n    public abstract void Purarea();\n\n&#125;\n\nclass Rectangle : Polygon\n\n&#123;\n\n    public override void Purarea()\n\n    &#123;\n\n        Console.WriteLine(&quot;Calculate the area of a rectangle.&quot;);\n\n    &#125;\n\n&#125;\n\n&#x2F;&#x2F; 使用示例\n\nPolygon polygon &#x3D; new Rectangle();\n\npolygon.Purarea(); &#x2F;&#x2F; 输出：Calculate the area of a rectangle.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这个示例中，我们定义了一个抽象类 <code>Polygon</code>  和一个非抽象子类 <code>Rectangle</code> ，它们都实现了 <code>Purarea</code>  方法。在使用示例中，我们创建了一个 <code>Rectangle</code>  对象，并将其赋值给 <code>Polygon</code>  类型的变量 <code>polygon</code> 。然后，我们调用 <code>polygon.Purarea()</code>  方法，它会调用 <code>Rectangle</code>  类中的 <code>Purarea</code>  方法，并输出 <code>Calculate the area of a rectangle.</code> 。</p>\n","text":"# 抽象方法只能在抽象类中定义 这个错误提示是因为您在抽象类 Polygon 中声明了一个抽象方法 Purarea ，但是没有为它提供方法体。在 C# 中，抽象方法必须以分号结尾，并且不能有方法体，因为它们没有实现，必须在子类中实现。 要解决这个问题，您需要为 Purarea 方...","link":"","photos":[],"count_time":{"symbolsCount":842,"symbolsTime":"1 mins."},"categories":[{"name":"BUG-C#","slug":"BUG-C","count":2,"path":"api/categories/BUG-C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":13,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":13,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":12,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\"> 抽象方法只能在抽象类中定义</span></a></li></ol>","author":{"name":"CenYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"c#/访问等级","uid":"b2e8321107bb1bee6888ca2a7202b079","slug":"学习笔记/Csharp/访问等级","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-22T18:04:53.750Z","comments":true,"path":"api/articles/学习笔记/Csharp/访问等级.json","keywords":null,"cover":null,"text":"# 访问等级（Access Level）是指在 C# 中用于控制类、结构体、接口、字段、属性、方法和构造函数等成员的可访问性的修饰符。C# 中有五个访问等级，从高到低分别是： public ：公共的，可以被任何代码访问。 protected internal ：受保护的内部的，可...","link":"","photos":[],"count_time":{"symbolsCount":391,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":13,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":13,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":12,"path":"api/tags/C.json"}],"author":{"name":"CenYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"c#/抽象方法（abstruct）和虚方法(virtual)的区别","uid":"da7125ed58b8c094cc6f04018e8ade4f","slug":"学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:37.762Z","comments":true,"path":"api/articles/学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别.json","keywords":null,"cover":null,"text":"实际上虚函数就类似于初省值 # 抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现 抽象方法和虚函数都是面向对象编程中的重要概念，它们都可以在基类中声明，然后在派生类中进行实现。它们的主要区别在于： 抽象方法必须在派生类中进行实现，而虚函数可以选择在派生类中...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":13,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":13,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":12,"path":"api/tags/C.json"}],"author":{"name":"CenYi","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}