{"title":"c#/静态类","uid":"c92b939053502639e9ed85c984e3e15d","slug":"学习笔记/Csharp/类的更多表现形式/静态类","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:36.472Z","comments":true,"path":"api/articles/学习笔记/Csharp/类的更多表现形式/静态类.json","keywords":null,"cover":[],"content":"<p>静态变量不可以通过实例来访问，只能通过类名，因为他是共有的。<br>\n<img src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230139796.png\" alt=\"Pasted image 20230620180951.png\"><br>\n<img src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230140156.png\" alt=\"Pasted image 20230620181011.png\"><br>\n 上面是错误示范<br>\n<img src=\"https://cenyi-picture-1317709115.cos.ap-shanghai.myqcloud.com/picture/202306230141887.png\" alt=\"Pasted image 20230620181325.png\"></p>\n<p>应该使用 MyClass3 这个类名而不是 myClass3 这个实例</p>\n","text":"静态变量不可以通过实例来访问，只能通过类名，因为他是共有的。 上面是错误示范 应该使用 MyClass3 这个类名而不是 myClass3 这个实例 ","link":"","photos":[],"count_time":{"symbolsCount":79,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"toc":"","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"c#/抽象函数","uid":"a3127223cee8ed98b2c97d067dde0e0d","slug":"学习笔记/Csharp/类的更多表现形式/抽象类","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:41.839Z","comments":true,"path":"api/articles/学习笔记/Csharp/类的更多表现形式/抽象类.json","keywords":null,"cover":[],"text":" # 抽象类不可被实例化 # 抽象类之中的抽象函数必须在子类写好实现的方法体 ","link":"","photos":[],"count_time":{"symbolsCount":41,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"c#/抽象方法（abstruct）和虚方法(virtual)的区别","uid":"da7125ed58b8c094cc6f04018e8ade4f","slug":"学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:37.762Z","comments":true,"path":"api/articles/学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别.json","keywords":null,"cover":null,"text":"实际上虚函数就类似于初省值 # 抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现 抽象方法和虚函数都是面向对象编程中的重要概念，它们都可以在基类中声明，然后在派生类中进行实现。它们的主要区别在于： 抽象方法必须在派生类中进行实现，而虚函数可以选择在派生类中...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}