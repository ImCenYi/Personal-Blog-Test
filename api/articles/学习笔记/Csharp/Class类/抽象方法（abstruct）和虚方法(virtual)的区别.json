{"title":"c#/抽象方法（abstruct）和虚方法(virtual)的区别","uid":"da7125ed58b8c094cc6f04018e8ade4f","slug":"学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:37.762Z","comments":true,"path":"api/articles/学习笔记/Csharp/Class类/抽象方法（abstruct）和虚方法(virtual)的区别.json","keywords":null,"cover":null,"content":"<p><mark>实际上虚函数就类似于初省值</mark></p>\n<h3 id=\"抽象函数只能定义在抽象类中并且不能在基类中写入方法体只能写在子类实现\"><a class=\"markdownIt-Anchor\" href=\"#抽象函数只能定义在抽象类中并且不能在基类中写入方法体只能写在子类实现\">#</a> <mark>抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现</mark></h3>\n<p>抽象方法和虚函数都是面向对象编程中的重要概念，它们都可以在基类中声明，然后在派生类中进行实现。它们的主要区别在于：</p>\n<ol>\n<li>抽象方法必须在派生类中进行实现，而虚函数可以选择在派生类中进行重写。</li>\n<li>抽象方法没有实现，只有方法签名，而虚函数有默认的实现 ==（必须）==，可以在基类中提供。</li>\n<li>抽象方法只能在抽象类中声明，而虚函数可以在普通的类中声明。</li>\n</ol>\n<p>下面是一个示例，演示了如何在抽象类中声明抽象方法和在普通类中声明虚函数：</p>\n<pre class=\"line-numbers language-C#\" data-language=\"C#\"><code class=\"language-C#\">abstract class Shape\n\n&#123;\n\n    public abstract double GetArea();&#x2F;&#x2F;这里的方法体必须是空\n\n&#125;\n\nclass Rectangle : Shape\n\n&#123;\n\n    public double Width &#123; get; set; &#125;\n\n    public double Height &#123; get; set; &#125;\n\n    public override double GetArea()&#x2F;&#x2F;子类写入方法体实现\n\n    &#123;\n\n        return Width * Height;\n\n    &#125;\n\n&#125;\nclass Circle : Shape\n\n&#123;\n\n    public double Radius &#123; get; set; &#125;\n\n    public override double GetArea(）\n\n    &#123;\n\n        return Math.PI * Radius * Radius;\n\n    &#125;\n\n&#125;\n\nclass Square : Shape\n\n&#123;\n\n    public double Side &#123; get; set; &#125;\n\n    public override double GetArea()\n\n    &#123;\n\n        return Side * Side;\n\n    &#125;\n\n&#125;\n\nclass Triangle : Shape\n\n&#123;\n\n    public double Base &#123; get; set; &#125;\n\n    public double Height &#123; get; set; &#125;\n\n    public override double GetArea()\n\n    &#123;\n\n        return 0.5 * Base * Height;\n\n    &#125;\n\n&#125;\n\n&#x2F;&#x2F; 使用示例\n\nShape shape1 &#x3D; new Rectangle &#123; Width &#x3D; 10, Height &#x3D; 20 &#125;;\n\nShape shape2 &#x3D; new Circle &#123; Radius &#x3D; 5 &#125;;\n\nShape shape3 &#x3D; new Square &#123; Side &#x3D; 10 &#125;;\n\nShape shape4 &#x3D; new Triangle &#123; Base &#x3D; 10, Height &#x3D; 5 &#125;;\n\nConsole.WriteLine(shape1.GetArea()); &#x2F;&#x2F; 输出：200\n\nConsole.WriteLine(shape2.GetArea()); &#x2F;&#x2F; 输出：78.53981633974483\n\nConsole.WriteLine(shape3.GetArea()); &#x2F;&#x2F; 输出：100\n\nConsole.WriteLine(shape4.GetArea()); &#x2F;&#x2F; 输出：25<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这个示例中，我们定义了一个抽象类 <code>Shape</code>  和四个子类 <code>Rectangle</code> 、 <code>Circle</code> 、 <code>Square</code>  和 <code>Triangle</code> ，它们都重写了 <code>GetArea</code>  方法。 <code>GetArea</code>  方法是一个抽象方法，必须在子类中实现。在使用示例中，我们创建了四个不同的形状对象，并分别调用它们的 <code>GetArea</code>  方法，输出了它们的面积。</p>\n<p><code>abstract</code>  和 <code>virtual</code>  都是 C# 中用于实现多态的关键字，它们的主要区别在于：</p>\n<ol>\n<li><code>abstract</code>  用于声明抽象方法，它必须在派生类中进行实现，而 <code>virtual</code>  用于声明虚方法，它可以在派生类中进行重写，但不是必须的。</li>\n<li><code>abstract</code>  方法没有实现，只有方法签名，而 <code>virtual</code>  方法有默认的实现，可以在基类中提供。</li>\n<li><code>abstract</code>  方法只能在抽象类中声明，而 <code>virtual</code>  方法可以在普通的类中声明。</li>\n</ol>\n","text":"实际上虚函数就类似于初省值 # 抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现 抽象方法和虚函数都是面向对象编程中的重要概念，它们都可以在基类中声明，然后在派生类中进行实现。它们的主要区别在于： 抽象方法必须在派生类中进行实现，而虚函数可以选择在派生类中...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E5%AE%9A%E4%B9%89%E5%9C%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%AD%E5%B9%B6%E4%B8%94%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%B8%AD%E5%86%99%E5%85%A5%E6%96%B9%E6%B3%95%E4%BD%93%E5%8F%AA%E8%83%BD%E5%86%99%E5%9C%A8%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\"> 抽象函数只能定义在抽象类中，并且不能在基类中写入方法体，只能写在子类实现</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"c#/静态类","uid":"c92b939053502639e9ed85c984e3e15d","slug":"学习笔记/Csharp/类的更多表现形式/静态类","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:36.472Z","comments":true,"path":"api/articles/学习笔记/Csharp/类的更多表现形式/静态类.json","keywords":null,"cover":[],"text":"静态变量不可以通过实例来访问，只能通过类名，因为他是共有的。 上面是错误示范 应该使用 MyClass3 这个类名而不是 myClass3 这个实例 ","link":"","photos":[],"count_time":{"symbolsCount":79,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"c#/抽象类","uid":"02a13521d1a9067da4901a7085158d6a","slug":"学习笔记/Csharp/类的更多表现形式/密封类","date":"2023-06-22T16:39:59.000Z","updated":"2023-06-23T04:11:34.772Z","comments":true,"path":"api/articles/学习笔记/Csharp/类的更多表现形式/密封类.json","keywords":null,"cover":[],"text":"/* 抽象类 1. 抽象类不可以被实例化 2. 抽象函数只能写在抽象类之中，并且抽象函数不能有方法体 3. 抽象类的子类必须实现抽象类中的所有抽象函数 4. 抽象类中可以有非抽象函数 5. 抽象类可以继承抽象类，但是子类必须实现所有抽象函数 6. 非抽象类可以继承抽象类，但是子类...","link":"","photos":[],"count_time":{"symbolsCount":345,"symbolsTime":"1 mins."},"categories":[{"name":"C#","slug":"C","count":10,"path":"api/categories/C.json"}],"tags":[{"name":"语言学习","slug":"语言学习","count":11,"path":"api/tags/语言学习.json"},{"name":"笔记","slug":"笔记","count":11,"path":"api/tags/笔记.json"},{"name":"C#","slug":"C","count":10,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}